# 인덱스의 유형과 특징

---

## B-Tree 인덱스

가장 보편적으로 사용되는 범용 인덱스 알고리즘. 스스로 균형을 유지하는 트리 구조를 통해 어떤 값이든 균일한 검색 성능을 보장하는 것이 특징임.

### B-Tree 인덱스의 구조

-   **계층적 블록 구조**: 루트, 브랜치, 리프 블록으로 구성된 계층 구조. 모든 리프 노드는 동일한 깊이에 위치하여 검색 성능이 균일함.
-   **B+Tree**: 현대 DBMS의 표준. 실제 데이터 위치 정보(ROWID)는 리프 노드에만 저장하고, 리프 노드끼리는 이중 연결 리스트로 연결하여 범위 검색 성능을 극대화한 구조.

### B-Tree 인덱스의 조작

#### 인덱스 생성

`CREATE INDEX` 구문 또는 `PRIMARY KEY`/`UNIQUE` 제약조건으로 생성. 테이블 스캔, 키 값 정렬, 트리 구조 구축 순으로 진행됨.

#### 인덱스 블록의 분할

새로운 데이터가 꽉 찬 블록에 삽입될 때 발생. 기존 노드와 새 노드로 데이터를 재분배하고, 중간값은 부모 노드로 올려보내 트리의 균형을 유지함. 이 과정이 루트 노드까지 전파되면 트리의 전체 높이가 증가함.

#### 데이터의 삭제 및 갱신

-   **삭제**: 물리적으로 바로 지우지 않고, 삭제 표시(delete-mark)를 남기는 논리적 삭제 방식을 사용. 공간은 나중에 재활용됨.
-   **갱신**: 기존 키 값을 논리적으로 삭제(DELETE)하고, 새로운 키 값을 삽입(INSERT)하는 두 단계의 작업으로 처리됨.

#### 인덱스를 경유한 검색

-   **단일 값 검색**: 루트 노드에서 리프 노드까지 키 값을 비교하며 찾아 내려감(트리 탐색).
-   **범위 검색**: 범위의 시작 값을 탐색한 후, 리프 노드의 연결 리스트를 따라 순차적으로 스캔하는 방식.

### 리버스 키(Reverse Key) 인덱스

인덱스 키 값을 바이트 단위로 역순으로 변환하여 B-Tree에 저장하는 방식.

-   **목적**: 시퀀스처럼 순차적으로 증가하는 키의 동시 입력 시, 특정 블록에만 I/O가 몰리는 '핫 스팟(hot spot)' 현상을 해결하기 위함. 키를 역순으로 만들어 인덱스 전역에 분산시켜 동시 쓰기 성능을 높임.
-   **한계**: 키의 정렬 순서가 파괴되므로, `BETWEEN` 이나 부등호(`>`, `<`)를 이용한 **범위 검색이 불가능**함. 오직 등가 비교(`=`) 검색만 가능.

---

## 비트맵 인덱스

컬럼의 각 고유 값에 대해 별도의 비트맵(bitmap)을 생성하는 구조. 하나의 비트맵은 테이블의 전체 행에 대한 존재 여부를 비트(0 또는 1)로 표시함.

### 비트맵 인덱스의 탄생배경

B-Tree 인덱스가 비효율적인 특정 상황을 해결하기 위해 등장함.

-   **낮은 카디널리티 컬럼**: '성별', '주문상태'처럼 고유 값의 종류가 적은 컬럼에 B-Tree를 사용하면 효율이 떨어짐.
-   **복잡한 다중 조건 쿼리**: `AND`, `OR`로 여러 조건이 결합될 때 B-Tree로는 처리가 복잡함.

### 비트맵 인덱스의 구조와 특성

-   **구조**: 각 컬럼 값마다 테이블 전체 로우 수만큼의 길이를 가진 비트 벡터를 생성. 특정 행에 해당 값이 존재하면 1, 아니면 0으로 표시.
-   **특성**: 저장 공간 효율성이 높고, 여러 조건을 CPU의 빠른 비트 연산(`AND`, `OR`, `NOT`)으로 처리할 수 있음.
-   **단점**: 데이터 한 건만 변경돼도 해당 비트맵 전체에 잠금(Lock)이 걸려 DML(입력, 수정, 삭제) 성능이 급격히 저하됨. 따라서 데이터 변경이 거의 없는 데이터 웨어하우스(DW) 환경에 적합함.

### 비트맵 인덱스의 액세스

여러 조건이 주어질 때 각 조건에 해당하는 비트맵을 가져와 비트 연산을 수행. 예를 들어 `'성별'='남' AND '상태'='활성'` 조건은 '남성' 비트맵과 '활성' 비트맵을 `AND` 연산하여 결과를 빠르게 도출함.

---

## 함수기반 인덱스

컬럼 원본 값이 아닌, 함수나 수식을 적용한 결과 값을 미리 계산하여 인덱스로 만드는 방식.

### 함수기반 인덱스의 개념 및 구조

-   **개념**: `UPPER(last_name)`처럼 컬럼 값에 함수를 적용한 결과를 B-Tree 또는 비트맵 구조로 저장. 쿼리 시 매번 함수를 계산하는 대신, 미리 저장된 인덱스 값을 사용함.
-   **원리**: 계산 시점을 읽기(read)에서 쓰기(write)로 전환하여 쿼리 성능을 높이는 것.

### 함수기반 인덱스의 제약사항

-   **정확한 표현식 일치**: `WHERE` 절의 조건이 인덱스 생성 시 사용된 표현식과 정확히 일치해야만 인덱스를 사용 가능함.
-   **DML 부하**: 데이터가 변경될 때마다 함수를 실행하여 인덱스 값을 계산해야 하므로 CPU 부하가 추가됨.
-   **결정적 함수**: `SYSDATE`처럼 실행할 때마다 결과가 바뀌는 비결정적 함수는 사용 불가.

### 함수기반 인덱스의 활용

#### 테이블 설계상의 문제를 해결

-   `UPPER()` 함수를 사용해 대소문자 구분 없는 검색을 구현.
-   `SUBSTR()` 함수로 특정 부분 문자열에 대한 검색 성능을 확보.

#### 오류 데이터의 검색 문제를 해결

-   `NVL()` 또는 `COALESCE()` 함수를 사용해 `NULL` 값을 특정 값으로 변환하여 인덱싱하고 검색에 활용.

#### 가공처리 결과의 검색

-   `(price * quantity)`와 같이 자주 사용되는 계산 결과를 미리 인덱싱하여 쿼리 시 연산 비용을 제거.

#### 오브젝트 타입의 인덱스 검색

-   객체 타입 컬럼의 특정 메소드 반환 값에 대해 인덱스를 생성.

#### 배타적 관계의 인덱스 검색

-   `CASE` 문을 활용한 고유 인덱스를 만들어, 여러 컬럼에 걸친 복잡한 비즈니스 규칙(예: 고객 유형에 따라 주민번호 또는 사업자번호의 유일성 보장)을 강제하고 검색을 단순화함.

---

# 데이터 저장구조와 특징

---

## 테이블과 인덱스의 분리형

### 분리형 테이블의 구조

데이터와 인덱스가 각각 독립된 물리적 공간(세그먼트)에 저장되는 가장 일반적인 구조. 각 행은 `ROWID`라는 고유한 물리적 주소 값을 통해 식별되며, 인덱스는 이 `ROWID`를 포인터처럼 사용하여 실제 데이터에 접근하는 것이 특징임.

-   **데이터베이스의 물리적 저장 공간**
    -   **테이블스페이스**: 데이터 파일로 구성된 논리적 저장 단위.
    -   **세그먼트**: 테이블, 인덱스 등 오브젝트가 저장되는 공간.
    -   **오브젝트**: 세그먼트를 구성하는 요소.
    -   **ROWID**: 각 행의 고유한 물리적 주소 값.

### 클러스터링 팩터

인덱스 키의 정렬 순서와 테이블에 저장된 실제 데이터 행의 물리적 정렬 순서가 얼마나 비슷한지를 나타내는 지표. 이 값이 좋을수록(유사할수록) 인덱스를 통한 범위 검색 시 디스크 I/O가 줄어들어 성능이 향상됨.

### 분리형 테이블의 엑세스 영향요소

#### 넓은 범위의 엑세스 처리에 대한 대처방안

-   **소형 테이블**: 특별한 조치 불필요.
-   **중형 테이블**: 가장 중요한 액세스 패턴을 분석하여 클러스터링 팩터 개선 등을 고려.
-   **대형 테이블 (VLDB)**: 데이터 특징(단순 저장형, 랜덤 액세스 위주, 혼합형)에 따라 파티셔닝 등 전문적인 기법을 적용해야 함.

#### 클러스터링 팩터 향상 전략

자주 함께 조회되는 데이터(액세스가 빈번한 데이터)들이 물리적으로 가까운 위치에 모이도록 테이블을 재구성하는 것.

---

## 인덱스 일체형 테이블(Index-Organized Table)

### 분리형과 일체형의 비교

분리형이 인덱스와 데이터를 별도 공간에 두는 반면, 일체형은 테이블 데이터를 인덱스 구조(B-Tree의 리프 노드) 안에 직접 저장하는 방식임.

### 일체형 테이블의 구조 및 특징

-   데이터 자체가 인덱스 키 순서대로 정렬되어 저장됨.
-   인덱스 탐색으로 데이터를 바로 찾을 수 있어 `PK` 기반 조회 성능이 매우 빠름.
-   별도의 테이블 저장 공간이 필요 없어 공간 효율적임.

### 논리적 ROWID와 물리적 주소(Physical Guess)

-   데이터의 물리적 위치가 DML에 따라 계속 바뀌므로 고정된 물리적 `ROWID`가 없음.
-   대신 `PK` 기반의 논리적 `ROWID`를 사용하며, 빠른 접근을 위해 이전 물리적 주소 정보(Physical Guess)를 힌트로 활용함.

### 오버플로우 영역(Overflow Area)

-   하나의 인덱스 블록에 저장하기에 행의 크기가 너무 클 경우, 일부 컬럼 데이터를 별도의 오버플로우 영역에 저장함.

### 일체형 테이블의 생성

테이블 생성 시 `ORGANIZATION INDEX` 옵션을 추가하여 생성함.

---

## 클러스터링 테이블

### 클러스터링이란?

유사하거나 연관된 데이터를 물리적으로 같은 공간에 모아두는 것.

### 클러스터링 테이블의 개념

특정 컬럼(클러스터 키) 값이 동일한 행들을 같은 디스크 블록에 모아서 저장하는 테이블 구조.

### 단일테이블 클러스터링

하나의 테이블을 대상으로 특정 컬럼 값을 기준으로 같은 값을 가진 행들을 같은 블록에 모아 저장하는 것. 클러스터 키를 조건으로 넓은 범위의 데이터를 조회할 때 I/O가 크게 줄어듦.

### 다중테이블 클러스터링

두 개 이상의 테이블을 하나의 클러스터 키를 기준으로 묶는 것. 조인될 행들이 이미 같은 블록에 저장되어 있어, 조인 성능이 극적으로 향상됨.

### 클러스터링 테이블의 비용

-   **장점**: 클러스터 키 기반 조회 시 최소한의 I/O만 사용하므로 조회 성능이 매우 높음.
-   **단점**:
    -   클러스터 키 이외의 값으로 조회하면 오히려 일반 테이블보다 비효율적일 수 있음.
    -   데이터를 모아서 저장해야 하므로 `INSERT`, `UPDATE`, `DELETE` 같은 DML 작업 시 성능이 저하될 수 있음.