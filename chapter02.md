# 인덱스의 유형과 특징

---

## B-Tree 인덱스

가장 보편적으로 사용되는 범용 인덱스 알고리즘. 스스로 균형을 유지하는 트리 구조를 통해 어떤 값이든 균일한 검색 성능을 보장하는 것이 특징임.

### B-Tree 인덱스의 구조

-   **계층적 블록 구조**: 루트, 브랜치, 리프 블록으로 구성된 계층 구조. 모든 리프 노드는 동일한 깊이에 위치하여 검색 성능이 균일함.
-   **B+Tree**: 현대 DBMS의 표준. 실제 데이터 위치 정보(ROWID)는 리프 노드에만 저장하고, 리프 노드끼리는 이중 연결 리스트로 연결하여 범위 검색 성능을 극대화한 구조.

### B-Tree 인덱스의 조작

#### 인덱스 생성

`CREATE INDEX` 구문 또는 `PRIMARY KEY`/`UNIQUE` 제약조건으로 생성. 테이블 스캔, 키 값 정렬, 트리 구조 구축 순으로 진행됨.

#### 인덱스 블록의 분할

새로운 데이터가 꽉 찬 블록에 삽입될 때 발생. 기존 노드와 새 노드로 데이터를 재분배하고, 중간값은 부모 노드로 올려보내 트리의 균형을 유지함. 이 과정이 루트 노드까지 전파되면 트리의 전체 높이가 증가함.

#### 데이터의 삭제 및 갱신

-   **삭제**: 물리적으로 바로 지우지 않고, 삭제 표시(delete-mark)를 남기는 논리적 삭제 방식을 사용. 공간은 나중에 재활용됨.
-   **갱신**: 기존 키 값을 논리적으로 삭제(DELETE)하고, 새로운 키 값을 삽입(INSERT)하는 두 단계의 작업으로 처리됨.

#### 인덱스를 경유한 검색

-   **단일 값 검색**: 루트 노드에서 리프 노드까지 키 값을 비교하며 찾아 내려감(트리 탐색).
-   **범위 검색**: 범위의 시작 값을 탐색한 후, 리프 노드의 연결 리스트를 따라 순차적으로 스캔하는 방식.

### 리버스 키(Reverse Key) 인덱스

인덱스 키 값을 바이트 단위로 역순으로 변환하여 B-Tree에 저장하는 방식.

-   **목적**: 시퀀스처럼 순차적으로 증가하는 키의 동시 입력 시, 특정 블록에만 I/O가 몰리는 '핫 스팟(hot spot)' 현상을 해결하기 위함. 키를 역순으로 만들어 인덱스 전역에 분산시켜 동시 쓰기 성능을 높임.
-   **한계**: 키의 정렬 순서가 파괴되므로, `BETWEEN` 이나 부등호(`>`, `<`)를 이용한 **범위 검색이 불가능**함. 오직 등가 비교(`=`) 검색만 가능.

---

## 비트맵 인덱스

컬럼의 각 고유 값에 대해 별도의 비트맵(bitmap)을 생성하는 구조. 하나의 비트맵은 테이블의 전체 행에 대한 존재 여부를 비트(0 또는 1)로 표시함.

### 비트맵 인덱스의 탄생배경

B-Tree 인덱스가 비효율적인 특정 상황을 해결하기 위해 등장함.

-   **낮은 카디널리티 컬럼**: '성별', '주문상태'처럼 고유 값의 종류가 적은 컬럼에 B-Tree를 사용하면 효율이 떨어짐.
-   **복잡한 다중 조건 쿼리**: `AND`, `OR`로 여러 조건이 결합될 때 B-Tree로는 처리가 복잡함.

### 비트맵 인덱스의 구조와 특성

-   **구조**: 각 컬럼 값마다 테이블 전체 로우 수만큼의 길이를 가진 비트 벡터를 생성. 특정 행에 해당 값이 존재하면 1, 아니면 0으로 표시.
-   **특성**: 저장 공간 효율성이 높고, 여러 조건을 CPU의 빠른 비트 연산(`AND`, `OR`, `NOT`)으로 처리할 수 있음.
-   **단점**: 데이터 한 건만 변경돼도 해당 비트맵 전체에 잠금(Lock)이 걸려 DML(입력, 수정, 삭제) 성능이 급격히 저하됨. 따라서 데이터 변경이 거의 없는 데이터 웨어하우스(DW) 환경에 적합함.

### 비트맵 인덱스의 액세스

여러 조건이 주어질 때 각 조건에 해당하는 비트맵을 가져와 비트 연산을 수행. 예를 들어 `'성별'='남' AND '상태'='활성'` 조건은 '남성' 비트맵과 '활성' 비트맵을 `AND` 연산하여 결과를 빠르게 도출함.

---

## 함수기반 인덱스

컬럼 원본 값이 아닌, 함수나 수식을 적용한 결과 값을 미리 계산하여 인덱스로 만드는 방식.

### 함수기반 인덱스의 개념 및 구조

-   **개념**: `UPPER(last_name)`처럼 컬럼 값에 함수를 적용한 결과를 B-Tree 또는 비트맵 구조로 저장. 쿼리 시 매번 함수를 계산하는 대신, 미리 저장된 인덱스 값을 사용함.
-   **원리**: 계산 시점을 읽기(read)에서 쓰기(write)로 전환하여 쿼리 성능을 높이는 것.

### 함수기반 인덱스의 제약사항

-   **정확한 표현식 일치**: `WHERE` 절의 조건이 인덱스 생성 시 사용된 표현식과 정확히 일치해야만 인덱스를 사용 가능함.
-   **DML 부하**: 데이터가 변경될 때마다 함수를 실행하여 인덱스 값을 계산해야 하므로 CPU 부하가 추가됨.
-   **결정적 함수**: `SYSDATE`처럼 실행할 때마다 결과가 바뀌는 비결정적 함수는 사용 불가.

### 함수기반 인덱스의 활용

#### 테이블 설계상의 문제를 해결

-   `UPPER()` 함수를 사용해 대소문자 구분 없는 검색을 구현.
-   `SUBSTR()` 함수로 특정 부분 문자열에 대한 검색 성능을 확보.

#### 오류 데이터의 검색 문제를 해결

-   `NVL()` 또는 `COALESCE()` 함수를 사용해 `NULL` 값을 특정 값으로 변환하여 인덱싱하고 검색에 활용.

#### 가공처리 결과의 검색

-   `(price * quantity)`와 같이 자주 사용되는 계산 결과를 미리 인덱싱하여 쿼리 시 연산 비용을 제거.

#### 오브젝트 타입의 인덱스 검색

-   객체 타입 컬럼의 특정 메소드 반환 값에 대해 인덱스를 생성.

#### 배타적 관계의 인덱스 검색

-   `CASE` 문을 활용한 고유 인덱스를 만들어, 여러 컬럼에 걸친 복잡한 비즈니스 규칙(예: 고객 유형에 따라 주민번호 또는 사업자번호의 유일성 보장)을 강제하고 검색을 단순화함.

### 클러스터링 테이블의 비용

-   **장점**: 클러스터 키 기반 조회 시 최소한의 I/O만 사용하므로 조회 성능이 매우 높음.
-   **단점**:
    -   클러스터 키 이외의 값으로 조회하면 오히려 일반 테이블보다 비효율적일 수 있음.
    -   데이터를 모아서 저장해야 하므로 `INSERT`, `UPDATE`, `DELETE` 같은 DML 작업 시 성능이 저하될 수 있음.
